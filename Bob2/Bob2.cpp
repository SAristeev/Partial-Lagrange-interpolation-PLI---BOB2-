#include <iostream>

double f(double x) {
	return x;
}
// K интервалов
// На каждом интервале степень полинома Лагранжа N
// Для построения нужно N точек на каждом из интервалов
// С учетом граничных точек общее количество узлов интерполяции 
// M = K * (N - 1) + 1
int main(){
	double a, b;
	const int K = 100; // Количество интервалов
	const int N = 10; // Степень интерполяционных многочленов Лагранжа
	const int M = K * (N - 1) + 1; // Общее количество узлов интерполяции
	double h = (b - a) / (M - 1); // Вычисляем шаг равномерной сетки, узлов у нас на 1 больше, чем интервалов, поэтому M - 1

	double mesh[M]; // Массив равномерной сетки
	for (int i = 0; i < M; i++) {
		mesh[i] = a + i * h; // вычисляем каждый узел равномерной сетки
	}

	const int count = 1920; // количество точек, по которым будем строить график
	double X[count]; // массив этих точек
	for (int i = 0; i < count; i++) {
		X[i] = a + i * (b - a) / (count - 1); // заполняем точки, по которым строим график
	}

	for (int i = 0; i < K; i++) {
		double D[N];
		for (int j = 0; j < N; j++) { // Вычисление знаменателя для многочлена Лагранжа на интервале
			D[j] = 1;
			for (int k = 0; k < N; k++) {
				D[j] *= mesh[i * (N - 1) + j] - mesh[i * (N - 1) + k]; // Смещенная индексация из-за того, что вычисляем на разных интервалах
			}
		}

		// Осталось выбрать точки, по которым будем строить многочлен
		// Вычислить погрешности
		// Вывести в значения в файлы
	}
	return 0;
}
